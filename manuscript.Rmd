---
title: 'Comparative RNA-Seq: Signal to Noise Documentation'
author: "T.J Nicholson & P.P Gardner"
date: "March 2022"
output:
  html_document:
    toc: yes
    toc_depth: 4
    toc_float: yes
    number_sections: yes
  html_notebook:
    toc: yes
    toc_depth: 4
  pdf_document:
    toc: yes
    toc_depth: '4'
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggtree)
library(treeio)
library(ape)
library(UpSetR)
library(svglite)
library(ROSE)
library(ggpubr)
source('~/bin/R/functions.R')

data_path = '~/bin/R/r_files/'
figure_path = '~/Google Drive/My Drive/Comparative_RNA-Seq/'
```


```{r toc, echo=FALSE, include=F} 
render_toc("manuscript.Rmd")
```

# Data Selection {#data_selection}

## Strains and experiments
How to get the summary table for the genera for the RNA-seq data:

-   Search the [SRA](https://www.ncbi.nlm.nih.gov/sra/) section of ncbi with 
    the genus name and ['Organism'] tag.

-   Select "Send results to Run selector"

-   Select the "Metadata" button of the "Total" row and "Download" Column.

-   The genome accession for each added genome was looked up on 
    [NCBI](https://www.ncbi.nlm.nih.gov/) using the strain name in the file or 
    by search for the given experiment in the 
    [SRA](https://www.ncbi.nlm.nih.gov/sra/) section.

-   Create a folder for the genus e.g. `mkdir Escherichia`

-   Create a folder using the GenBank assembly 
    accession e.g. `mkdir GCA_002504285.1.data/`

-   Create an `experiments_list.txt` file listing all of the SRA experiments 
    for the given genome and save the file in the `genus` folder.
    
-   Run `callPeaksforGenome.sh -g <GCA Accession> -s` from within 
    the `genus` folder.

-   List of representative genomes selected from RefSeq95
    -   2 genomes from each genera were selected (where possible)
    
## Predicting sRNAs

-   The `callPeaksforGenome.sh` carried out a number of steps
    -   `fasterq-dump <SRA Accession>` downloaded each of the RNA-Seq files
        listed in the `experiments_list.txt` file.
    -   `fetch_genomes_from_GCA.sh` downloaded the nucleotide FASTA file and
        the annotation file in GFF3 format.
    -   Known ncRNAs are identified using `cmscan` with models from Rfam
    -   `sra2plot.1.0.3.sh` took these files and produced a plot file (showing
        read depths at each nucleotide position) for each of the experiments.
    -   `run_rnaPeakCalling.R` took these plot files and identfied regions of
        RNA expression tht occured in intergenic regions
    -   `combine_gff_files.R` took the expressed regions from each of the 
        individual files (including the annotation file) and merged regions
        where there was an overlap.

-   The resulting regions are separated into `Known sRNA` and `Putative RUFs`
    based on whether an expressed region overlapped with a previously 
    identified ncRNA

-   The negative control group (RINCs) was generated 
    using `get_random_srna_sequences.py`
      -   For each putative RUF, a region of the same size was selected at 
          random from an intergenic region in the same genome

```{bash get_random_srna_sequences_loop, eval = F}
for file in *.txt; do 
  accession=`basename $file _new_calls.txt`; 
  get_random_srna_sequences.py -a $accession; 
  done
```

- The nucleotide sequences for each group were obtained from the nucleotide
  FASTA files using the coordinates of the regions

## Analysis

### Homology Search

-   `run_sRNA_nhmmer.sh -d <group_seqs.fna> -f <path/to/sequences/> -e fna`
    -   The `-e` flag is for the the expected extension of the input files.
    -   This loops through all the individual sequences in each data set and
        carries out a similarity search against all the sequences in the data
        set.
    -   The matched sequences are removed from the remaining search list to 
        prevent multiple identical alignments being produced.
        
-   `run_sRNA_nhmmer.sh -d <path/to/genomes/> -f <path/to/initial_alignment> -o` 
    `<path_to_output>/ -e stk -E 1e-3`
    -   The `-E` flag sets the e-value threshold for inclusion.
    -   This gets repeated two times to generate deep alignments for the 
        sequences from each data set.
        
-   A check was carried out for each of the groups (known sRNAs, predicted 
    RUFs and RINCs) that none of the alignments shared sequences.
      -   RINCs sharing sequences with either of the other data sets were 
          removed.
      -   Predicted RUFs sharing sequences with the known sRNAs were removed.
      

```{bash, eval=F}
group='predicted' #repeat for each group
cd ${group}/alignments/
> ../${group}_contig_pos.txt
for file in *.stk;
do 
  ID=`basename $file .stk`
  
  # extract the contig name and position for each sequence in each stockholm
  #alignment file
  grep "/" $file | grep -v "//" | cut -d ' ' -f1 | sed 's/\// /g' | 
  sed 's/-/ /g'| cut -d '|' -f2 | sort | uniq | sed -e "s/$/ $ID/" >> 
  ../${group}_contig_pos.txt
done

```
      
```{r eval=F}
library(GenomicRanges)
ncdat <- read.table("negative_control_contig_pos.txt", sep = " ", fill = T)

pcdat <- read.table("positive_control_contig_pos.txt", fill = T)

preddat <- read.table("predicted_contig_pos.txt", fill = T)

pcdat <- reformatContigPositionData(dat = pcdat)
ncdat <- reformatContigPositionData(dat = ncdat)
preddat <- reformatContigPositionData(dat = preddat)

nc.pc.Dat <- getOverlapIDs(queryDat =ncdat, targetDat = pcdat)
nc.pred.Dat <- getOverlapIDs(queryDat =ncdat, targetDat = preddat)
pc.pred.Dat <- getOverlapIDs(queryDat =preddat, targetDat = pcdat)

dat <- data.frame(ids = c(nc.pc.Dat$id1, nc.pred.Dat$id1))

write.table(dat, file = "not_negative_control_ids.txt", row.names = F, col.names = F, quote = F)

dat2 <- data.frame(ids =  pc.pred.Dat$id1)

write.table(dat2, file = "not_predicted_ids.txt", row.names = F, col.names = F, quote = F)

```

-   A similar check was carried out within each group to reduce redundancy
    -   Alignments sharing a sequence were merged into a single alignment.

```{bash, eval=F}

```


### Evolutionary Distance

-   A `cmscan` of all the genomes using the RF00177 Rfam model (bacterial 
      ribosomal SSU) was carried out.
-   [Phylip](https://evolution.genetics.washington.edu/phylip.html) was used to 
    build a maximum likelihood phyogenetic tree.
      -   The `RF00177.stk` alignment was reformatted to `.phylip` format
      -   `esl-reformat phylip RF00177.stk > RF00177.phylip`
      -   This was used as the input for `dnadist` with an output of 
          `RF00177.dnadist`.
      
      


## UpsetR figure

```{r upsetr_tree, eval=F}
#ML phylogenetic tree built using 16s rRNA for the Gammaproteobacteria
#The full tree was also built for all bacterial genera, but is not displayed
tree <- read.tree(paste0(data_path, 'upsetr.tree'))

  tbl_tree <- as_tibble(tree)
  
#list of extra Gammaproteobacteria that were 
#not included in the RNA-sed analysis
to_drop <- c("Azotobacter", "Marinobacter", "Pseudoalteromonas", "Agarivorans", 
             "Vibrio", "Alishewanella", "Aggregatibacter", "Mannheimia", 
             "Actinobacillus", "Xenorhabdus", "Providencia", "Proteus",
             "Pantoea", "Brenneria", "Lonsdalea", "Buchnera.", "Wigglesworthia", 
             "Sodalis", "Dickeya", "Citrobacter", "Plautiasymbiont", 
             "Shewanella", "Moritella", "Moraxella", "Psychrobacter", 
             "Methylomonas", "Cycloclasticus", "Methylococcus", "Francisella",
             "Pseudoxanthomonas", "Candidatus", "Plautia", "Methylophaga", 
             "Pasteurella", "Salinivibrio")
  

  sub_tree <- drop.tip(tree, to_drop)
  
    tbl_sub_tree <- as_tibble(sub_tree)

  
p <- ggtree(sub_tree) + 
  geom_tiplab(align = T) +
  xlim(0, 0.35)

p
if(FALSE){
ggsave(filename = paste0(figure_path, "SVG/upsetr_subset_tree.svg"), 
       plot = p, width = 8, height = 16)
}
p <- ggtree(tree) + 
  geom_tiplab(align = T) +
  xlim(0, 0.5)

p
if(FALSE){
ggsave(filename = paste0(figure_path, "SVG/upsetr_tree.svg"), 
       plot = p, width = 8, height = 16)
}
```

```{r upsetr_plot, eval=F}
#matrix of bool values indicating for each RNA if it was found in a genus
load(paste0(data_path, "upsetSubsetPC.Rda"))
load(paste0(data_path, "upsetSubsetPredicted.Rda"))

#list of extra Gammaproteobacteria that were 
#not included in the RNA-sed analysis
genera_arranged <- c("Lysobacter", "Stenotrophomonas", "Xylella", "Xanthomonas", 
                     "Methylomicrobium", "Pseudomonas", "Acinetobacter", 
                     "Alteromonas", "Photorhabdus", "Yersinia", "Erwinia", 
                     "Edwardsiella", "Serratia", "Klebsiella", "Enterobacter", 
                     "Salmonella", "Shigella", "Escherichia")


upset_pred <- select_columns_by_list(upsetSubsetPredicted, genera_arranged)
upset_pc <- select_columns_by_list(upsetSubsetPC, genera_arranged)

UpSetR::upset(upset_pc, sets = colnames(upset_pc), 
              mb.ratio = c(0.55, 0.45), order.by = "freq", keep.order = T)
UpSetR::upset(upset_pred, sets = colnames(upset_pred), 
              mb.ratio = c(0.55, 0.45), order.by = "freq", keep.order = T)



if(FALSE){
svglite(filename=paste0(figure_path, "SVG/upsetr_pc.svg"))
UpSetR::upset(upset_pc, sets = colnames(upset_pc), 
              mb.ratio = c(0.55, 0.45), order.by = "freq", keep.order = T)
dev.off()
svglite(filename=paste0(figure_path, "SVG/upsetr_pred.svg"))
UpSetR::upset(upset_pred, sets = colnames(upset_pred), 
              mb.ratio = c(0.55, 0.45), order.by = "freq", keep.order = T)
dev.off()
}

```

```{r expressed_regions_frequency_plot, eval=F}
#matrix of bool values indicating for each RNA if it was found in a genus
load(paste0(data_path, "upsetSubsetPC.Rda"))
load(paste0(data_path, "upsetSubsetPredicted.Rda"))


#list of extra Gammaproteobacteria that were not included in the RNA-sed analyis
genera_arranged <- c("Lysobacter", "Stenotrophomonas", "Xylella", "Xanthomonas", 
                     "Methylomicrobium", "Pseudomonas", "Acinetobacter", 
                     "Alteromonas", "Photorhabdus", "Yersinia", "Erwinia", 
                     "Edwardsiella", "Serratia", "Klebsiella", "Enterobacter", 
                     "Salmonella", "Shigella", "Escherichia")

upset_pred <- select_columns_by_list(upsetSubsetPredicted, genera_arranged)
upset_pc <- select_columns_by_list(upsetSubsetPC, genera_arranged)

pc_freq <- colSums(upset_pc)
pred_freq <- colSums(upset_pred)

pc_freq <- vector_to_dataframe(pc_freq, 'genera')
pred_freq <- vector_to_dataframe(pred_freq, 'genera')

pc_freq <- pc_freq %>% dplyr::rename(freq = vec) %>% mutate(group ='pc')
pred_freq <- pred_freq %>% dplyr::rename(freq = vec) %>% mutate(group ='pred')

freq_data <-pc_freq %>% bind_rows(pred_freq)

freq_data$genera <- factor(freq_data$genera, levels = unique(freq_data$genera))

p <- ggplot() +
  geom_bar(data = freq_data, 
           aes(y = genera, x = freq, group = group, fill = group), 
           stat = 'identity', position = 'dodge')

p

if(FALSE){
  ggsave(filename = paste0(figure_path, 'SVG/rnas_frequency.svg'), 
  plot = p, width = 8, height = 16)
}

```

## Random forest interpretation figure 

  -   The output of the RF classifier for the test data and the predicted RUFs

```{r random_forest_frequency_plots, }
load("~/bin/PhD/Chapter_4/chapter_4_files/predDat.Rda")
load("~/bin/PhD/Chapter_4/chapter_4_files/validatation2.Rda")
#select the desired columns from the predicted data and validatation data

probDat <- predDat %>% 
  select(probability, ID, group, srna.counts.2) %>% 
  bind_rows(validation2 %>% select(probability, ID, group, srna.counts.2))

#not sure if setting factors will break anything so using another data frame
plotDat <- probDat
plotDat$group <- factor(plotDat$group, 
                        levels = c('Positive Control', 
                                   'Predicted', 
                                   'Negative Control'))

#plot histogram of the probabilities
p <- ggplot() +
  geom_histogram(data = plotDat, 
                 aes(x = probability, 
                     y = ..density.., 
                     group = group, 
                     fill = group), 
                 binwidth = 0.02) +
  geom_vline(xintercept = 0.17) +
  geom_vline(xintercept = 0.5) 
p

if(FALSE){
  ggsave(filename = paste0(figure_path, "SVG/histogram_probabilities.svg"), 
         plot = p, width = 178, height = 155, units = "mm")
}

#get the cumulative counts of the number of alignments as probability increases
countsCumul <- cumulativeCounts(dists = probDat, 
                                smooth = F, 
                                target_column = 'probability')

##produces plot to use for figure showing probability results
p <- ggplot() +
  geom_line(data = countsCumul, aes(x= probability, 
                                    y = cumulative_prop,
                                    group = group, 
                                    colour = group),
            size = 1.5, 
            show.legend = F) +
  scale_y_continuous(trans = 'log10')
p + theme_classic()

if(FALSE){
  ggsave(filename = paste0(figure_path, "SVG/cumulative_probabilities.svg"), 
                           plot = p, width = 178, height = 155, units = "mm")
}
```

  -   The predicted RUFs were split into <strong>transcriptional noise</strong>, 
      <strong>possible RNA</strong>, and <strong>putative RNA</strong>.
  -   The categories were then compared to see if there was a difference in the
      level of transcription between the groups.

```{r transcription_levels_by_result}




```



```{r random_forest_statistics, eval=F}
#TODO this is not used
load("~/bin/PhD/Chapter_4/chapter_4_files/predDat.Rda")
load("~/bin/PhD/Chapter_4/chapter_4_files/validatation2.Rda")

#select the desired columns from the predicted data and validatation data
probDat <- predDat %>% 
  select(probability, ID, group, srna.counts.2) %>% 
  bind_rows(validation2 %>% 
              select(probability, ID, group, srna.counts.2))

#not sure if setting factors will break anything so using another data frame
plotDat <- probDat
plotDat$group <- factor(plotDat$group, 
                        levels = c('Positive Control', 
                                   'Predicted', 
                                   'Negative Control'))
dat <- allScores(plotDat, 0.01, 'probability')

#get the FNR and PPV values at each threshold
if(FALSE){
  for(i in seq(0,1, by=0.01)){
    scores <- scoreProbabities(plotDat, 
                               threshold = i, 
                               target_column = 'probability')
    print(paste0(i, ': ', scores$fnr, ', ', scores$ppv))
  }
}


scores <- scoreProbabities(plotDat, 
                           threshold = 0.17, 
                           target_column = 'probability')
printListSubset(scores, 
                vec = c('ppv', 'fnr', 'pred_pos', 'pred_pct'), 
                startText = 'p > 0.17', round_val = 3)


scores <- scoreProbabities(plotDat, 
                           threshold = 0.5, 
                           target_column = 'probability')
printListSubset(scores, 
                vec = c('ppv', 'fnr', 'pred_pos', 'pred_pct', 'pc_pct'), 
                startText = 'p > 0.5', round_val = 3)


scores <- scoreProbabities(plotDat, 
                           threshold = 0.81, 
                           target_column = 'probability')
printListSubset(scores, 
                vec = c('ppv', 'fnr', 'pred_pos', 'pred_pct', 'pc_pct'), 
                startText = 'p > 0.81', round_val = 3)



```

```{r statistics_plots, eval=F}
#TODO this is not used
load("~/bin/PhD/Chapter_4/chapter_4_files/predDat.Rda")
load("~/bin/PhD/Chapter_4/chapter_4_files/validatation2.Rda")

#select the desired columns from the predicted data and validatation data
probDat <- predDat %>% 
  select(probability, ID, group, srna.counts.2) %>% 
  bind_rows(validation2 %>% 
              select(probability, ID, group, srna.counts.2))

#not sure if setting factors will break anything so using another data frame
plotDat <- probDat
plotDat$group <- factor(plotDat$group, 
                        levels = c('Positive Control', 
                                   'Predicted', 
                                   'Negative Control'))
dat <- allScores(plotDat, 0.01, 'probability')

ggplot(data = dat) + 
  geom_line(aes(x = threshold, y = ppv), color = 'blue') + 
  geom_line(aes(x = threshold, y = fnr), color = 'red')


roc.curve(response = plotDat$group[plotDat$group != 'Predicted'], 
          predicted = plotDat$probability[plotDat$group != 'Predicted'])

ggplot(data = dat) + 
  geom_line(aes(x = fnr, y = specificity), color = 'blue') + 
  geom_line(aes(x = fpr, y = sensitivity), color = 'red')


```


```{r repeat_of_cumulative_distributions, eval=F}
#TODO this is not used
#is there a difference between low scoring (p < 0.17 and high scoring p > 0.5) predicted rufs?


load("~/bin/Phd/Chapter_4/chapter_4_files/predDat.Rda")
load("~/bin/Phd/Chapter_4/chapter_4_files/validatation2.Rda")
##function written using max_dist as column name so each variable needs to  be renamed to this before using cumulativeDistribution()

featuresSelected <- predDat %>% 
  mutate(group = ifelse(probability > 0.75, 'high', ifelse(probability <= 0.17, 'low', 'drop'))) %>% 
  filter(group != 'drop') %>% select(group, distance, read.max.score, 
                                     cov.min.eval, z_max, motif.max.score,
                                     alifold_cov_score, mfe.score, 
                                     gc.score) %>% 
  bind_rows(validation2 %>% filter(group == 'Positive Control') %>% 
              select(group, distance, read.max.score, 
                                     cov.min.eval, z_max, motif.max.score,
                                     alifold_cov_score, mfe.score, 
                                     gc.score))

dat <- featuresSelected %>% dplyr::rename(max_dist = distance) %>% filter(max_dist <= 0.15)
distance.p <- cumulativeDistribution(dat, alternative = "two.sided", show.legend = F)
distance.p <- distance.p +
   labs(y = "Cumulative Proportion", x = "Evolutionary distance")

##known sRNAs and predicted RUFs are only selected if there is read depths. For a fair comparison, RINCs with read depths of 0 are removed.
dat <- featuresSelected %>% select(group, read.max.score) %>% dplyr::rename(max_dist = read.max.score) %>% filter(max_dist > 0)
reads.p <- cumulativeDistribution(dat, alternative = 'two.sided', show.legend = F)
reads.p <- reads.p +
   labs(y = "Cumulative Proportion", x = "Total reads")+
  scale_x_continuous(trans = "log10")
#reads.p

dat <- featuresSelected %>% mutate(max_dist = -log(cov.min.eval))
rscape.p <- cumulativeDistribution(dat)
rscape.p <- rscape.p +
   labs(y = "Cumulative Proportion", x = "Rscape covariance score")
# rscape.p

##none of the z scores are greater than 3, so the NA value of 10 is changed to 3 (then the negaive is taken for the plot)
dat <- featuresSelected %>% mutate(max_dist = ifelse(z_max == 10, -3, -z_max)) %>% select(group, max_dist)
z.p <- cumulativeDistribution(dat, show.legend = F)
z.p <- z.p +
   labs(y = "Cumulative Proportion", x = "Alifold z-score (negative energy)")

# z.p
##selected a window where the values are easier to visualise. This has removed 16 known sRNAs and 9 predicted RUFs
dat <- featuresSelected %>% dplyr::rename(max_dist = motif.max.score) %>% filter(max_dist < 1000)
motif.p <- cumulativeDistribution(dat)
motif.p <- motif.p +
   labs(y = "Cumulative Proportion", x = "Motif score")

dat <- featuresSelected %>% mutate(max_dist = -alifold_cov_score) 
alifold.cov.p <- cumulativeDistribution(dat)
alifold.cov.p <- alifold.cov.p +
   labs(y = "Cumulative Proportion", x = "Alifold covariance score")

dat <- featuresSelected %>% mutate(max_dist = -mfe.score)
mfe.p <- cumulativeDistribution(dat, alternative = 'two.sided')
mfe.p <- mfe.p +
   labs(y = "Cumulative Proportion", x = "MFE score (negative energy)")


dat <- featuresSelected %>% arrange(gc.score) %>% mutate(gc.score = round(gc.score))

highCounts <- dat %>% filter(group == "high") %>% group_by(gc.score) %>% summarise(count = n()) %>% arrange(gc.score) %>% ungroup() %>% tidyr::complete(gc.score = seq(from = 0, to = 100, by = 1), fill = list(count = 0))
lowCounts <- dat %>% filter(group == "low") %>% group_by(gc.score) %>% summarise(count = n()) %>% arrange(gc.score) %>% ungroup() %>% tidyr::complete(gc.score = seq(from = 0, to = 100, by = 1), fill = list(count = 0))

highTotal <- dat %>% filter(group == "high") %>% nrow()
lowTotal <- dat %>% filter(group == "low") %>% nrow()

highGC <- zoo::zoo(highCounts$count)
lowGC <- zoo::zoo(lowCounts$count)

smoothHigh <- zoo::rollapply(highGC, width = 10, by = 1, FUN = mean, align = "center", partial = T) 
smoothLow <- zoo::rollapply(lowGC, width = 10, by = 1, FUN = mean, align = "center", partial = T) 

smoothHigh <- as.data.frame(smoothHigh) %>% mutate(x = row_number() -1) %>% mutate(group = "high") %>% dplyr::rename(y = smoothHigh) %>% mutate(y = y/highTotal)
smoothLow <- as.data.frame(smoothLow) %>% mutate(x = row_number() -1) %>% mutate(group = "low") %>% dplyr::rename(y = smoothLow) %>% mutate(y = y/lowTotal)

pcCounts <- dat %>% filter(group == "Positive Control") %>% group_by(gc.score) %>% summarise(count = n()) %>% arrange(gc.score) %>% ungroup() %>% tidyr::complete(gc.score = seq(from = 0, to = 100, by = 1), fill = list(count = 0))
pcTotal <- dat %>% filter(group == "Positive Control") %>% nrow()
pcGC <- zoo::zoo(pcCounts$count)
smoothPC <- zoo::rollapply(pcGC, width = 10, by = 1, FUN = mean, align = "center", partial = T) 
smoothPC <- as.data.frame(smoothPC) %>% mutate(x = row_number() -1) %>% mutate(group = "Positive Control") %>% dplyr::rename(y = smoothPC) %>% mutate(y = y/pcTotal)

smoothGC <- smoothHigh %>%  bind_rows(smoothLow, smoothPC)

gc.p <- ggplot() +
  geom_path(data = smoothGC, aes(x = x, y = y, group = group, color = group), size = 1, show.legend = FALSE)  + labs(y = "Proportion", x = "GC percentage")  + theme_classic()



all.p <- ggarrange(distance.p, reads.p, mfe.p, z.p, rscape.p, alifold.cov.p,  motif.p, gc.p + rremove("x.text"),
          labels = LETTERS[1:9],
          ncol = 3, nrow = 3)

all.p


if(FALSE){
ggsave(filename = paste0(figure_path, "SVG/separated_distributions.svg"), plot = all.p, width = 450, height = 307, units = "mm")
}


```

